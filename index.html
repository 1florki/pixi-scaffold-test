<!doctype html>
<meta charset="utf-8">
<title>pixi scaffold</title>

<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
<meta name="apple-mobile-web-app-capable" content="yes">

<body style="background-color:black; margin: 0; height: 100%; overflow: hidden">

  <script src="./helper/helper.js"></script>
  <script src="./helper/engine.js"></script>

  <style>
  
@font-face {
    font-family: 'pixeloid_sansregular';
    src: url('pixeloidsans.woff2') format('woff2'),
         url('pixeloidsans.woff') format('woff');
    font-weight: normal;
    font-style: normal;

}
  </style>
  
  <script>
    class SnakeGame {
      constructor(opts) {
        opts = opts || {};
        this.gridX = 15;
        this.gridY = 30;
        this.cellSize = 20;

        if(window.innerWidth > window.innerHeight) {
          let a = this.gridX;
          this.gridX = this.gridY;
          this.gridY = a;
        }
        
        this.w = this.gridX * this.cellSize + 40;
        this.h = this.gridY * this.cellSize + 60;
        
        this.centerZero = true
        // 7, 9
        this.noise = {scale: 0.1, pow: 2, seed: 15}
        
        this.title = "Snake"
      }

      setup(px) {
        this.px = px;
        
        
        this.setupGame(px);
        
        px.scene = "menu"
      }
      
      setupGame(px) {
        
        px.scene = "game"
        px.removeAll();
        
        let obstacles = [];
        // draw grid
        for (let x = 0; x < this.gridX; x++) {
          obstacles.push([]);
          for (let y = 0; y < this.gridY; y++) {
            obstacles[x][y] = px.noise(this.gridX < this.gridY ? x : y, this.gridX < this.gridY ? y : x) > 0;
            
            let s = px.createShape({
              s: this.cellSize,
              strokeWeight: 1.2,
              stroke: obstacles[x][y] ? 0x555555 : 0x777777,
              color: obstacles[x][y] ? 0x555555 : 0,
            });
            s.zIndex = obstacles[x][y] ? 100 : 0
            this.setPosition(s, x, y);
          }
        }
        
        this.obstacles = obstacles;
        
        this.dir = new Vector(1, 0);
        this.newDir = new Vector(1, 0);
        
        this.snakeItems = [];
        this.snake = [new Vector(Math.floor(this.gridX / 2), Math.floor(this.gridY / 2))];
        this.updateSnake();
        
        this.grow = 3;
        
        
        this.foodItem = px.createShape({s: this.cellSize + 1, color: 0xffffff});
        this.placeFood(px);
        
        this.scoreItem = px.createShape({y: this.h / 2 - 20, x: this.w / 2 - 5, text: "0", textColor: 0xffffff, textAlign: "right"})
      }
      
      updateSnake() {
        while(this.snakeItems.length < this.snake.length) {
          let s = this.px.createShape({s: this.cellSize, color: 0x00ffff, alpha: 1, stroke: 0});
          s.zIndex = 200
          this.snakeItems.push(s);
        }
        
        for(let i = 0; i < this.snake.length && i < this.snakeItems.length; i++) {
          this.setPosition(this.snakeItems[i], this.snake[i].x, this.snake[i].y);
          this.snakeItems[i].color = MathUtils.hsl2hex(((i + this.px.totalTime * 0.001) / 40) % 1, 1, 0.5);
        }
      }
      
      setPosition(item, x, y) {
        item.x = x * this.cellSize + this.cellSize / 2 - this.w / 2 + 20;
        item.y = y * this.cellSize + this.cellSize / 2 - this.h / 2 + 20;
      }
      
      placeFood() {
        this.food = new Vector(Math.floor(this.px.random(this.gridX)), Math.floor(this.px.random(this.gridY)));
        
        if(this.obstacles[this.food.x][this.food.y]) {
          this.placeFood();
          return;
        }
        
        for(let s of this.snake) {
          if(s.x == this.food.x && s.y == this.food.y) {
            this.placeFood();
            return;
          }
        }
        this.setPosition(this.foodItem, this.food.x, this.food.y);
      }
/*
      tap(px) {
        if(px.scene == "menu") px.scene = "game";
        if(px.scene == "gameover") {
          this.setupGame(px);
          px.scene = "game";
        }
      }*/
      
      restart(px) {
        this.setupGame(px);
      }
      
      loop(px, dt) {
        if(px.scene != "game") return;
        
        
        this.frameTime = (this.frameTime || 0) + dt;
        if(this.frameTime < 200) return;
        
        this.frameTime = 0;
        
        let head = this.snake[0];
        
        if(Math.abs(this.dir.x + this.newDir.x) == 1 ||Â Math.abs(this.dir.y + this.newDir.y) == 1) {
          this.dir.copy(this.newDir);
        }
        
        let newHead = new Vector(head.x + this.dir.x, head.y + this.dir.y);
        if(newHead.x >= this.gridX) newHead.x = 0;
        if(newHead.y >= this.gridY) newHead.y = 0;
        if(newHead.x < 0) newHead.x = this.gridX - 1;
        if(newHead.y < 0) newHead.y = this.gridY - 1;
        
        this.snake.unshift(newHead);
        
        if(newHead.x == this.food.x && newHead.y == this.food.y) {
          this.grow += 1;
          this.placeFood();
        }
        
        if(this.grow <= 0) {
          this.snake.pop();
        } else {
          this.grow -= 1;
        }
        
        this.scoreItem.text = this.snake.length
        
        // check for death
        for(let i = 1; i < this.snake.length; i++) {
          if(this.snake[i].x == newHead.x && this.snake[i].y == newHead.y) {
            px.scene = "gameover"
            return
          }
        }
        if(this.obstacles[newHead.x][newHead.y]) {
          px.scene = "gameover"
          return
          
        }
        
        
        this.updateSnake();
        
      }


      swipe(px, evt) {
        if (evt.direction == 4) {
          this.newDir.set(1, 0);
        } else if (evt.direction == 8) {
          this.newDir.set(0, -1);
        } else if (evt.direction == 16) {
          this.newDir.set(0, 1);
        } else if (evt.direction == 2) {
          this.newDir.set(-1, 0);
        }
      }

      keyDown(px, key) {
        if (key == "d") {
          this.newDir.set(1, 0);
        } else if (key == "a") {
          this.newDir.set(-1, 0);
        } else if (key == "w") {
          this.newDir.set(0, -1);
        } else if (key == "s") {
          this.newDir.set(0, 1);
        } else if(key == "f") {
          px.toggleFullscreen();
        }
      }
    }
    new PixiEngine(new SnakeGame());
    
  </script>
</body>